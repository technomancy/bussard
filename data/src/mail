-- This -*- lua -*- code defines your message client.

-- There are two modes; mail and message. The first is for listing/navigating
-- your mail folders, and the second defines a mode for reading messages.

mail = function()
   editor.open(nil, "*mail*", "mail")
end

local targets = {} -- things you can press enter to open

local header = function(lines, header)
   for _,line in ipairs(lines) do
      local match = utf8.match(line, header .. ": (.+)")
      if(match) then return match end
   end
end

-- returns a string which summarizes a message in a single line for folder view.
local describe = function(msg)
   local lines = lume.split(msg, "\n")
   local date = utils.pad_to(header(lines, "Date") or "", 17)
   local from = utils.pad_to(header(lines, "From"), 32)
   local subject = header(lines, "Subject")
   return date .. " | " .. from .. " | " .. subject
end

-- return a sorted table of messages by date field, if present.
local subjects_by_date = function(msgs)
   local by_date, names = {}, {}
   for name, msg in pairs(msgs) do
      if(name ~= "_unread") then
         local date = header(lume.split(msg, "\n"), "Date")
         local key = date and utils.parse_time(date) or
            header(lume.split(msg, "\n"), "Subject")
         if(by_date[key] and type(key) == "number") then
            by_date[key+1] = name
         elseif(by_date[key]) then
            by_date[key .. "_"] = name
         else
            by_date[key or 0] = name
         end
      end
   end
   for _, date in lume.ripairs(lume.sort(lume.keys(by_date))) do
      table.insert(names, by_date[date])
   end
   return names
end

local archive_key = "alt-a"

-- sometimes the modeline should show a hint hint for the archive command.
local set_modeline = function(folder)
   if(folder == "archive") then
      editor.set_modeline(function(b)
            return utf8.format(" %s  -  (%s/%s)  %s",
                               folder, b.point_line, #b.lines,
                               b.mode, archive_key) end)
   else
      editor.set_modeline(function(b)
            return utf8.format(" %s  -  (%s/%s)  %s   Press %s to archive.",
                               folder or "folders", b.point_line, #b.lines,
                               b.mode, archive_key) end)
   end
end

local open_folder_fn = function(folder)
   editor.end_of_buffer()
   local point, point_line = editor.point()
   editor.delete(1, 0, point_line, point)
   set_modeline(folder)

   local p = function(x) editor.raw_write(x .. "\n") end
   targets = {}

   if(folder) then -- display the contents of the current folder.
      p("Folder: " .. folder .. "\n")
      local msgs = ship.docs.mail[folder]
      ship.docs.mail[folder]._unread = ship.docs.mail[folder]._unread or {}
      for _,name in ipairs(subjects_by_date(msgs)) do
         local msg = msgs[name]
         if(name ~= "_unread") then
            table.insert(targets, {folder, name})
            if(ship.docs.mail[folder]._unread[name]) then
               p(" * " .. describe(msg))
            else
               p(" - " .. describe(msg))
            end
         end
      end
   else -- display a list of folders.
      p("Folders\n")
      local folder_list = lume.sort(lume.keys(ship.docs.mail))
      lume.remove(folder_list, "inbox")
      table.insert(folder_list, 1, "inbox")
      for _,name in ipairs(folder_list) do
         table.insert(targets, name)
         local unread_count = lume.count(ship.docs.mail[name]._unread or {})
         local count = lume.count(ship.docs.mail[name]) - 1
         p(" [" .. unread_count .. "/" .. count .. "] " .. name)
      end
   end
   editor.beginning_of_buffer()
   editor.next_line()
   editor.next_line()
end

local open_folder = lume.fn(editor.suppress_read_only, open_folder_fn)

inbox = function()
   editor.open(nil, "*mail*", "mail")
   open_folder("inbox")
end

define_mode("mail", "edit", {activate=open_folder, read_only=true})

local reply_key = "alt-enter"

local view_modeline = function(b)
   local id = header(b.lines, "Message.Id")
   local subject = header(b.lines, "Subject")
   if(replyable(id)) then
      return utf8.format(" %s  (%s/%s)  %s   Press %s to reply.",
                         subject, b.point_line, #b.lines, b.mode, reply_key)
   else
      return utf8.format(" %s  (%s/%s)  %s",
                         subject, b.point_line, #b.lines, b.mode)
   end
end

local open_message_or_folder = function()
   local line = editor.get_line_number()
   local target = targets[line-2] -- two lines at the top before listing

   if(type(target) == "table") then -- two values means open individual msg
      local folder, name = unpack(target)
      ship.docs.mail[folder]._unread[name] = nil
      open_folder(folder)
      editor.open(ship, "docs.mail." .. folder .. "." .. name)
      ship:activate_mode("message")
      editor.set_prop("read_only", true)
      editor.set_modeline(view_modeline)
   else -- single value means open a folder
      open_folder(target)
   end
end

bind("mail", "return", open_message_or_folder)
bind("mail", "alt-up", open_folder)

local archive_from_folder = function()
   local line = editor.get_line_number()
   local target = targets[line-2] -- two lines at the top before listing
   if(type(target) == "table") then -- two values means a message
      local folder, name = unpack(target)
      ship.docs.mail.archive[name] = ship.docs.mail[folder][name]
      ship.docs.mail[folder][name] = nil
      ship.docs.mail[folder]._unread[name] = nil
      open_folder(folder)
   end
end

bind("mail", archive_key, archive_from_folder)

local colorize_message = function(_, colors, lines)
   local headers = {"From", "To", "Cc", "Content.Type", "Subject", "Date",
                    "Message.Id", "In.Reply.To",}
   local colorize_line = function(line)
      if(line:find("^>")) then return {colors.quote, line} end
      for _,h in pairs(headers) do
         local start, len = line:find("^"..h..":")
         if(start) then return {colors.header, line:sub(1,len),
                                colors.text, line:sub(len+1, -1)}
         end
      end
      return {colors.text, line}
   end
   return lume.map(lines, colorize_line)
end

-- inherit most bindings from edit, but disable text insertion
define_mode("message", "edit", {read_only=true,
                                activate = editor.colorize,
                                colorize = colorize_message})

-- mail-specific colors
editor.set_color("message", {header={0,255,0},
                             text={0,200,0},
                             quote={200,100,0}})

local open_up_folder = function()
   local path = editor.current_buffer_path()
   local folder = path:match("docs.mail.([^\\.]+).")
   editor.open(nil, "*mail*")
   ship:activate_mode("mail")
   open_folder(folder)
end

local archive = function()
   local path = editor.current_buffer_path()
   local _, _, folder, name = unpack(lume.split(path, "."))
   ship.docs.mail.archive[name] = ship.docs.mail[folder][name]
   ship.docs.mail[folder]._unread[name] = nil
   ship.docs.mail[folder][name] = nil
   editor.close()
   editor.change_buffer("*mail*")
   open_folder(folder)
end

bind("message", "alt-a", archive)
bind("message", "alt-up", open_up_folder)

local reply = function()
   local id = header(editor.get_lines(), "Message.Id")
   local success, status = reply(id)
   editor.close()
   editor.open(ship, "*console*")
   if(success) then
      print("Replied.", status)
   else
      print(status)
   end
end

bind("message", reply_key, reply)
